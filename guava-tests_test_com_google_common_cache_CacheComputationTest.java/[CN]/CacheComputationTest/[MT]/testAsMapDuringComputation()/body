{
  final AtomicInteger callCount=new AtomicInteger();
  final CountDownLatch getStartedSignal=new CountDownLatch(1);
  final CountDownLatch letGetFinishSignal=new CountDownLatch(1);
  final CountDownLatch getFinishedSignal=new CountDownLatch(1);
  final String singleKey="bar";
  CacheLoader<String,String> computeFunction=new CacheLoader<String,String>(){
    @Override public String load(    String key) throws InterruptedException {
      callCount.incrementAndGet();
      getStartedSignal.countDown();
      letGetFinishSignal.await();
      return key + "foo";
    }
  }
;
  final Cache<String,String> cache=CacheBuilder.newBuilder().build(computeFunction);
  new Thread(){
    @Override public void run(){
      cache.getUnchecked(singleKey);
      getFinishedSignal.countDown();
    }
  }
.start();
  getStartedSignal.await();
  ConcurrentMap<String,String> map=cache.asMap();
  assertEquals(0,map.size());
  assertFalse(map.containsKey(singleKey));
  letGetFinishSignal.countDown();
  getFinishedSignal.await();
  assertEquals(1,cache.size());
  assertTrue(map.containsKey(singleKey));
}
