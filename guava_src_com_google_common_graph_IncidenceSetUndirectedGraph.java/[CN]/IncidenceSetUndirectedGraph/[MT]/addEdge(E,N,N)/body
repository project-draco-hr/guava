{
  checkNotNull(edge,"edge");
  checkNotNull(node1,"node1");
  checkNotNull(node2,"node2");
  UndirectedIncidentNodes<N> incidentNodes=UndirectedIncidentNodes.of(node1,node2);
  checkArgument(config.isSelfLoopsAllowed() || !incidentNodes.isSelfLoop(),SELF_LOOPS_NOT_ALLOWED,node1);
  UndirectedIncidentNodes<N> previousIncidentNodes=edgeToIncidentNodes.get(edge);
  if (previousIncidentNodes != null) {
    checkArgument(previousIncidentNodes.equals(incidentNodes),REUSING_EDGE,edge,previousIncidentNodes,incidentNodes);
    return false;
  }
 else   if (!config.isMultigraph() && containsNode(node1) && containsNode(node2)) {
    E edgeConnecting=Iterables.getOnlyElement(edgesConnecting(node1,node2),null);
    checkArgument(edgeConnecting == null,ADDING_PARALLEL_EDGE,node1,node2,edgeConnecting);
  }
  for (  N node : incidentNodes) {
    addNode(node);
    nodeToIncidentEdges.get(node).add(edge);
  }
  edgeToIncidentNodes.put(edge,incidentNodes);
  return true;
}
