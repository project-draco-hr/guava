{
  return new Maps.EntrySet<V,K>(){
    @Override Map<V,K> map(){
      return Inverse.this;
    }
    @Override public Iterator<Entry<V,K>> iterator(){
      return new Itr<Entry<V,K>>(){
        @Override Entry<V,K> output(        BiEntry<K,V> entry){
          return new InverseEntry(entry);
        }
class InverseEntry extends AbstractMapEntry<V,K> {
          BiEntry<K,V> delegate;
          InverseEntry(          BiEntry<K,V> entry){
            this.delegate=entry;
          }
          @Override public V getKey(){
            return delegate.getValue();
          }
          @Override public K getValue(){
            return delegate.getKey();
          }
          @Override public K setValue(          K key){
            int smearedKeyHash=Hashing.smearedHash(key);
            if (delegate.matchesKey(key,smearedKeyHash)) {
              return key;
            }
            checkArgument(seekByKey(key,smearedKeyHash) == null,"value already present: %s",key);
            delete(delegate);
            BiEntry<K,V> newEntry=new BiEntry<K,V>(key,smearedKeyHash,delegate.getValue(),delegate.smearedValueHash);
            insert(newEntry);
            expectedModCount=modCount;
            K oldKey=delegate.getKey();
            delegate=newEntry;
            return oldKey;
          }
        }
      }
;
    }
  }
;
}
