{
  return new Itr<Entry<K,V>>(){
    @Override Entry<K,V> output(    BiEntry<K,V> entry){
      return new MapEntry(entry);
    }
class MapEntry extends ForwardingMapEntry<K,V> {
      BiEntry<K,V> delegate;
      MapEntry(      BiEntry<K,V> entry){
        this.delegate=entry;
      }
      @Override protected Entry<K,V> delegate(){
        return delegate;
      }
      @Override public V setValue(      V value){
        int smearedValueHash=Hashing.smearedHash(value);
        if (delegate.matchesValue(value,smearedValueHash)) {
          return value;
        }
        checkArgument(seekByValue(value,smearedValueHash) == null,"value already present: %s",value);
        delete(delegate);
        BiEntry<K,V> newEntry=new BiEntry<K,V>(delegate.getKey(),delegate.smearedKeyHash,value,smearedValueHash);
        insert(newEntry);
        expectedModCount=modCount;
        if (toRemove == delegate) {
          toRemove=newEntry;
        }
        V oldValue=delegate.getValue();
        delegate=newEntry;
        return oldValue;
      }
    }
  }
;
}
