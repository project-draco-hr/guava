{
  final BstBalancePolicy<N> singleBalancePolicy=BstCountBasedBalancePolicies.<K,N>singleRebalancePolicy();
  return new BstBalancePolicy<N>(){
    @Override public N balance(    BstNodeFactory<N> nodeFactory,    N source,    @Nullable N left,    @Nullable N right){
      if (left == null) {
        return insertMin(right,source,nodeFactory,singleBalancePolicy);
      }
 else       if (right == null) {
        return insertMax(left,source,nodeFactory,singleBalancePolicy);
      }
      int countL=left.count();
      int countR=right.count();
      if (SINGLE_ROTATE_RATIO * countL <= countR) {
        N resultLeft=balance(nodeFactory,source,left,right.childOrNull(LEFT));
        return singleBalancePolicy.balance(nodeFactory,right,resultLeft,right.childOrNull(RIGHT));
      }
 else       if (SINGLE_ROTATE_RATIO * countR <= countL) {
        N resultRight=balance(nodeFactory,source,left.childOrNull(RIGHT),right);
        return singleBalancePolicy.balance(nodeFactory,left,left.childOrNull(LEFT),resultRight);
      }
 else {
        return nodeFactory.createNode(source,left,right);
      }
    }
    @Nullable @Override public N combine(    BstNodeFactory<N> nodeFactory,    @Nullable N left,    @Nullable N right){
      if (left == null) {
        return right;
      }
 else       if (right == null) {
        return left;
      }
      int countL=left.count();
      int countR=right.count();
      if (SINGLE_ROTATE_RATIO * countL <= countR) {
        N resultLeft=combine(nodeFactory,left,right.childOrNull(LEFT));
        return singleBalancePolicy.balance(nodeFactory,right,resultLeft,right.childOrNull(RIGHT));
      }
 else       if (SINGLE_ROTATE_RATIO * countR <= countL) {
        N resultRight=combine(nodeFactory,left.childOrNull(RIGHT),right);
        return singleBalancePolicy.balance(nodeFactory,left,left.childOrNull(LEFT),resultRight);
      }
 else {
        return singleBalancePolicy.combine(nodeFactory,left,right);
      }
    }
  }
;
}
