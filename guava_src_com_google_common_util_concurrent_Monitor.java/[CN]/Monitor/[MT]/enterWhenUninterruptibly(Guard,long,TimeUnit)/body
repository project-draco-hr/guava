{
  if (guard.monitor != this) {
    throw new IllegalMonitorStateException();
  }
  final ReentrantLock lock=this.lock;
  boolean reentrant=lock.isHeldByCurrentThread();
  boolean interruptIgnored=false;
  try {
    long remainingNanos;
    if (!fair && lock.tryLock()) {
      remainingNanos=unit.toNanos(time);
    }
 else {
      long startNanos=System.nanoTime();
      long timeoutNanos=unit.toNanos(time);
      remainingNanos=timeoutNanos;
      while (true) {
        try {
          if (lock.tryLock(remainingNanos,TimeUnit.NANOSECONDS)) {
            break;
          }
 else {
            return false;
          }
        }
 catch (        InterruptedException ignored) {
          interruptIgnored=true;
        }
 finally {
          remainingNanos=(timeoutNanos - (System.nanoTime() - startNanos));
        }
      }
    }
    boolean satisfied=false;
    try {
      satisfied=waitUninterruptibly(guard,remainingNanos,reentrant);
    }
  finally {
      if (!satisfied) {
        lock.unlock();
      }
    }
    return satisfied;
  }
  finally {
    if (interruptIgnored) {
      Thread.currentThread().interrupt();
    }
  }
}
