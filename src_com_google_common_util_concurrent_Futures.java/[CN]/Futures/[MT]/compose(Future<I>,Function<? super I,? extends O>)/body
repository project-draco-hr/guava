{
  if (future instanceof ListenableFuture) {
    return compose((ListenableFuture<I>)future,function);
  }
  checkNotNull(future);
  checkNotNull(function);
  return new Future<O>(){
    private final Object lock=new Object();
    private boolean set=false;
    private O value=null;
    private ExecutionException exception=null;
    @Override public O get() throws InterruptedException, ExecutionException {
      return apply(future.get());
    }
    @Override public O get(    long timeout,    TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
      return apply(future.get(timeout,unit));
    }
    private O apply(    I raw) throws ExecutionException {
synchronized (lock) {
        if (!set) {
          try {
            value=function.apply(raw);
          }
 catch (          RuntimeException e) {
            exception=new ExecutionException(e);
          }
catch (          Error e) {
            exception=new ExecutionException(e);
          }
          set=true;
        }
        if (exception != null) {
          throw exception;
        }
        return value;
      }
    }
    @Override public boolean cancel(    boolean mayInterruptIfRunning){
      return future.cancel(mayInterruptIfRunning);
    }
    @Override public boolean isCancelled(){
      return future.isCancelled();
    }
    @Override public boolean isDone(){
      return future.isDone();
    }
  }
;
}
