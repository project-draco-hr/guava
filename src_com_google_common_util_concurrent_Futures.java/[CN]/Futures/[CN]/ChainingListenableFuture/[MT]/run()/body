{
  try {
    I sourceResult;
    try {
      sourceResult=makeUninterruptible(inputFuture).get();
    }
 catch (    CancellationException e) {
      cancel();
      return;
    }
catch (    ExecutionException e) {
      setException(e.getCause());
      return;
    }
    final ListenableFuture<? extends O> outputFuture=this.outputFuture=function.apply(sourceResult);
    if (isCancelled()) {
      try {
        outputFuture.cancel(mayInterruptIfRunningChannel.take());
      }
 catch (      InterruptedException ignored) {
        Thread.currentThread().interrupt();
      }
      this.outputFuture=null;
      return;
    }
    outputFuture.addListener(new Runnable(){
      @Override public void run(){
        try {
          set(makeUninterruptible(outputFuture).get());
        }
 catch (        CancellationException e) {
          cancel();
          return;
        }
catch (        ExecutionException e) {
          setException(e.getCause());
        }
 finally {
          ChainingListenableFuture.this.outputFuture=null;
        }
      }
    }
,MoreExecutors.sameThreadExecutor());
  }
 catch (  UndeclaredThrowableException e) {
    setException(e.getCause());
  }
catch (  RuntimeException e) {
    setException(e);
  }
catch (  Error e) {
    setException(e);
  }
 finally {
    function=null;
    inputFuture=null;
    outputCreated.countDown();
  }
}
