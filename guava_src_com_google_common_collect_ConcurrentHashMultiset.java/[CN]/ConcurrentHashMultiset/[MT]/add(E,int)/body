{
  if (occurrences == 0) {
    return count(element);
  }
  checkArgument(occurrences > 0,"Invalid occurrences: %s",occurrences);
  while (true) {
    AtomicInteger existingCounter=safeGet(element);
    if (existingCounter == null) {
      existingCounter=countMap.putIfAbsent(element,new AtomicInteger(occurrences));
      if (existingCounter == null) {
        return 0;
      }
    }
    while (true) {
      int oldValue=existingCounter.get();
      if (oldValue != 0) {
        checkArgument(occurrences <= Integer.MAX_VALUE - oldValue,"Overflow adding %s occurrences to a count of %s",occurrences,oldValue);
        int newValue=oldValue + occurrences;
        if (existingCounter.compareAndSet(oldValue,newValue)) {
          return oldValue;
        }
      }
 else {
        AtomicInteger newCounter=new AtomicInteger(occurrences);
        if ((countMap.putIfAbsent(element,newCounter) == null) || countMap.replace(element,existingCounter,newCounter)) {
          return 0;
        }
        break;
      }
    }
  }
}
