{
  CountingFunction computingFunction=new CountingFunction();
  for (  MapMaker maker : allEvictingMakers()) {
    ComputingConcurrentHashMap<Object,Object> map=makeComputingMap(maker.concurrencyLevel(1),computingFunction);
    Segment<Object,Object> segment=map.segments[0];
    List<ReferenceEntry<Object,Object>> writeOrder=Lists.newLinkedList();
    List<ReferenceEntry<Object,Object>> readOrder=Lists.newLinkedList();
    for (int i=0; i < SMALL_MAX_SIZE; i++) {
      Object key=new Object();
      int hash=map.hash(key);
      map.getOrCompute(key);
      ReferenceEntry<Object,Object> entry=segment.getEntry(key,hash);
      writeOrder.add(entry);
      readOrder.add(entry);
    }
    checkEvictionQueues(map,segment,readOrder,writeOrder);
    checkExpirationTimes(map);
    Random random=new Random();
    List<ReferenceEntry<Object,Object>> reads=Lists.newArrayList();
    Iterator<ReferenceEntry<Object,Object>> i=readOrder.iterator();
    while (i.hasNext()) {
      ReferenceEntry<Object,Object> entry=i.next();
      if (random.nextBoolean()) {
        map.getOrCompute(entry.getKey());
        reads.add(entry);
        i.remove();
      }
    }
    readOrder.addAll(reads);
    checkEvictionQueues(map,segment,readOrder,writeOrder);
    checkExpirationTimes(map);
  }
}
