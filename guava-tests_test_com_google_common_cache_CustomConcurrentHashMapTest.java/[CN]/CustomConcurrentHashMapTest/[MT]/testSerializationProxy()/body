{
  CacheLoader<Object,Object> loader=new SerializableCacheLoader();
  RemovalListener<Object,Object> listener=new SerializableRemovalListener<Object,Object>();
  SerializableWeigher<Object,Object> weigher=new SerializableWeigher<Object,Object>();
  Ticker ticker=new SerializableTicker();
  LocalCache<Object,Object> one=(LocalCache)CacheBuilder.newBuilder().weakKeys().softValues().expireAfterAccess(123,NANOSECONDS).maximumWeight(789).weigher(weigher).concurrencyLevel(12).removalListener(listener).ticker(ticker).build(loader);
  one.getUnchecked(new Object());
  assertEquals(1,one.size());
  assertFalse(one.asMap().isEmpty());
  LocalCache<Object,Object> two=SerializableTester.reserialize(one);
  assertEquals(0,two.size());
  assertTrue(two.asMap().isEmpty());
  CustomConcurrentHashMap<Object,Object> mapOne=one.map;
  CustomConcurrentHashMap<Object,Object> mapTwo=two.map;
  assertEquals(mapOne.loader,mapTwo.loader);
  assertEquals(mapOne.keyStrength,mapTwo.keyStrength);
  assertEquals(mapOne.keyStrength,mapTwo.keyStrength);
  assertEquals(mapOne.valueEquivalence,mapTwo.valueEquivalence);
  assertEquals(mapOne.valueEquivalence,mapTwo.valueEquivalence);
  assertEquals(mapOne.maxWeight,mapTwo.maxWeight);
  assertEquals(mapOne.weigher,mapTwo.weigher);
  assertEquals(mapOne.expireAfterAccessNanos,mapTwo.expireAfterAccessNanos);
  assertEquals(mapOne.expireAfterWriteNanos,mapTwo.expireAfterWriteNanos);
  assertEquals(mapOne.removalListener,mapTwo.removalListener);
  assertEquals(mapOne.ticker,mapTwo.ticker);
}
