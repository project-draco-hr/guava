{
  CacheLoader<Object,Object> loader=new SerializableCacheLoader();
  RemovalListener<Object,Object> listener=new SerializableRemovalListener<Object,Object>();
  Ticker ticker=new SerializableTicker();
  ComputingCache<Object,Object> one=(ComputingCache)CacheBuilder.newBuilder().weakKeys().softValues().expireAfterAccess(123,NANOSECONDS).maximumSize(789).concurrencyLevel(12).removalListener(listener).ticker(ticker).build(loader);
  one.getUnchecked(new Object());
  assertEquals(1,one.size());
  assertFalse(one.asMap().isEmpty());
  ComputingCache<Object,Object> two=SerializableTester.reserialize(one);
  assertEquals(0,two.size());
  assertTrue(two.asMap().isEmpty());
  CustomConcurrentHashMap<Object,Object> mapOne=one.map;
  CustomConcurrentHashMap<Object,Object> mapTwo=two.map;
  assertEquals(mapOne.loader,mapTwo.loader);
  assertEquals(mapOne.keyStrength,mapTwo.keyStrength);
  assertEquals(mapOne.keyStrength,mapTwo.keyStrength);
  assertEquals(mapOne.valueEquivalence,mapTwo.valueEquivalence);
  assertEquals(mapOne.valueEquivalence,mapTwo.valueEquivalence);
  assertEquals(mapOne.maximumSize,mapTwo.maximumSize);
  assertEquals(mapOne.expireAfterAccessNanos,mapTwo.expireAfterAccessNanos);
  assertEquals(mapOne.expireAfterWriteNanos,mapTwo.expireAfterWriteNanos);
  assertEquals(mapOne.removalListener,mapTwo.removalListener);
  assertEquals(mapOne.ticker,mapTwo.ticker);
}
