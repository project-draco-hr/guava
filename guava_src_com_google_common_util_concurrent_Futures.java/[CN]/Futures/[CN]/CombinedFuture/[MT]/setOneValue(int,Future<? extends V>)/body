{
  List<Optional<V>> localValues=values;
  if (isDone() || localValues == null) {
    checkState(allMustSucceed,"Future was done before all dependencies completed");
    return;
  }
  try {
    checkState(future.isDone(),"Tried to set value from future which is not done");
    V returnValue=getUninterruptibly(future);
    localValues.set(index,Optional.fromNullable(returnValue));
  }
 catch (  CancellationException e) {
    if (allMustSucceed) {
      cancel(false);
    }
  }
catch (  ExecutionException e) {
    if (allMustSucceed) {
      setException(e.getCause());
    }
  }
catch (  RuntimeException e) {
    if (allMustSucceed) {
      setException(e);
    }
  }
catch (  Error e) {
    setException(e);
  }
 finally {
    int newRemaining=remaining.decrementAndGet();
    checkState(newRemaining >= 0,"Less than 0 remaining futures");
    if (newRemaining == 0) {
      FutureCombiner<V,C> localCombiner=combiner;
      if (localCombiner != null) {
        set(localCombiner.combine(localValues));
      }
 else {
        checkState(isDone());
      }
    }
  }
}
