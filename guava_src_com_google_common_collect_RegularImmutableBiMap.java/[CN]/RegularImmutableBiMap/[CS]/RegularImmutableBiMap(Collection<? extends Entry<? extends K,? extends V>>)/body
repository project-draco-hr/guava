{
  int n=entriesToAdd.size();
  int tableSize=RegularImmutableMap.chooseTableSize(n);
  this.mask=tableSize - 1;
  BiMapEntry<K,V>[] kToVTable=createEntryArray(tableSize);
  BiMapEntry<K,V>[] vToKTable=createEntryArray(tableSize);
  BiMapEntry<K,V>[] entries=createEntryArray(n);
  int i=0;
  int hashCode=0;
  for (  Entry<? extends K,? extends V> entry : entriesToAdd) {
    K key=checkNotNull(entry.getKey());
    V value=checkNotNull(entry.getValue());
    int keyHash=key.hashCode();
    int valueHash=value.hashCode();
    int keyBucket=Hashing.smear(keyHash) & mask;
    int valueBucket=Hashing.smear(valueHash) & mask;
    BiMapEntry<K,V> nextInKToVBucket=kToVTable[keyBucket];
    for (BiMapEntry<K,V> kToVEntry=nextInKToVBucket; kToVEntry != null; kToVEntry=kToVEntry.getNextInKToVBucket()) {
      if (key.equals(kToVEntry.getKey())) {
        throw new IllegalArgumentException("Multiple entries with same key: " + entry + " and "+ kToVEntry);
      }
    }
    BiMapEntry<K,V> nextInVToKBucket=vToKTable[valueBucket];
    for (BiMapEntry<K,V> vToKEntry=nextInVToKBucket; vToKEntry != null; vToKEntry=vToKEntry.getNextInVToKBucket()) {
      if (value.equals(vToKEntry.getValue())) {
        throw new IllegalArgumentException("Multiple entries with same value: " + entry + " and "+ vToKEntry);
      }
    }
    BiMapEntry<K,V> newEntry=(nextInKToVBucket == null && nextInVToKBucket == null) ? new BiMapEntry<K,V>(key,value) : new NonTerminalBiMapEntry<K,V>(key,value,nextInKToVBucket,nextInVToKBucket);
    kToVTable[keyBucket]=newEntry;
    vToKTable[valueBucket]=newEntry;
    entries[i++]=newEntry;
    hashCode+=keyHash ^ valueHash;
  }
  this.kToVTable=kToVTable;
  this.vToKTable=vToKTable;
  this.entries=entries;
  this.hashCode=hashCode;
}
