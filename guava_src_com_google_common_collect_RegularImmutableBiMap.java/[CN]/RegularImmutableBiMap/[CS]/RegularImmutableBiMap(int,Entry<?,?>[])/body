{
  int tableSize=Hashing.closedTableSize(n,MAX_LOAD_FACTOR);
  this.mask=tableSize - 1;
  BiMapEntry<K,V>[] kToVTable=createEntryArray(tableSize);
  BiMapEntry<K,V>[] vToKTable=createEntryArray(tableSize);
  BiMapEntry<K,V>[] entries=createEntryArray(n);
  int hashCode=0;
  for (int i=0; i < n; i++) {
    Entry<?,?> entry=entriesToAdd[i];
    @SuppressWarnings("unchecked") K key=(K)checkNotNull(entry.getKey());
    @SuppressWarnings("unchecked") V value=(V)checkNotNull(entry.getValue());
    int keyHash=key.hashCode();
    int valueHash=value.hashCode();
    int keyBucket=Hashing.smear(keyHash) & mask;
    int valueBucket=Hashing.smear(valueHash) & mask;
    BiMapEntry<K,V> nextInKToVBucket=kToVTable[keyBucket];
    for (BiMapEntry<K,V> kToVEntry=nextInKToVBucket; kToVEntry != null; kToVEntry=kToVEntry.getNextInKToVBucket()) {
      checkNoConflict(!key.equals(kToVEntry.getKey()),"key",entry,kToVEntry);
    }
    BiMapEntry<K,V> nextInVToKBucket=vToKTable[valueBucket];
    for (BiMapEntry<K,V> vToKEntry=nextInVToKBucket; vToKEntry != null; vToKEntry=vToKEntry.getNextInVToKBucket()) {
      checkNoConflict(!value.equals(vToKEntry.getValue()),"value",entry,vToKEntry);
    }
    BiMapEntry<K,V> newEntry=(nextInKToVBucket == null && nextInVToKBucket == null) ? new BiMapEntry<K,V>(key,value) : new NonTerminalBiMapEntry<K,V>(key,value,nextInKToVBucket,nextInVToKBucket);
    kToVTable[keyBucket]=newEntry;
    vToKTable[valueBucket]=newEntry;
    entries[i]=newEntry;
    hashCode+=keyHash ^ valueHash;
  }
  this.kToVTable=kToVTable;
  this.vToKTable=vToKTable;
  this.entries=entries;
  this.hashCode=hashCode;
}
