{
  int n=entriesToAdd.length;
  int tableSize=Hashing.closedTableSize(n,MAX_LOAD_FACTOR);
  this.mask=tableSize - 1;
  ImmutableMapEntry<K,V>[] keyTable=createEntryArray(tableSize);
  ImmutableMapEntry<K,V>[] valueTable=createEntryArray(tableSize);
  ImmutableMapEntry<K,V>[] entries=createEntryArray(n);
  int hashCode=0;
  for (int i=0; i < n; i++) {
    @SuppressWarnings("unchecked") Entry<K,V> entry=(Entry<K,V>)entriesToAdd[i];
    K key=entry.getKey();
    V value=entry.getValue();
    checkEntryNotNull(key,value);
    int keyHash=key.hashCode();
    int valueHash=value.hashCode();
    int keyBucket=Hashing.smear(keyHash) & mask;
    int valueBucket=Hashing.smear(valueHash) & mask;
    ImmutableMapEntry<K,V> nextInKeyBucket=keyTable[keyBucket];
    checkNoConflictInKeyBucket(key,entry,nextInKeyBucket);
    ImmutableMapEntry<K,V> nextInValueBucket=valueTable[valueBucket];
    checkNoConflictInValueBucket(value,entry,nextInValueBucket);
    ImmutableMapEntry<K,V> newEntry=(nextInKeyBucket == null && nextInValueBucket == null) ? new TerminalEntry<K,V>(key,value) : new NonTerminalBiMapEntry<K,V>(key,value,nextInKeyBucket,nextInValueBucket);
    keyTable[keyBucket]=newEntry;
    valueTable[valueBucket]=newEntry;
    entries[i]=newEntry;
    hashCode+=keyHash ^ valueHash;
  }
  this.keyTable=keyTable;
  this.valueTable=valueTable;
  this.entries=entries;
  this.hashCode=hashCode;
}
