{
  try {
    outer:     while (true) {
      ReferenceEntry<K,V> e=getEntry(key,hash);
      if (e != null) {
        V value=getLiveValue(e);
        if (value != null) {
          recordRead(e);
          statsCounter.recordHit();
          return value;
        }
      }
      if (e == null || !e.getValueReference().isComputingReference()) {
        ComputingValueReference<K,V> computingValueReference=null;
        lock();
        try {
          preWriteCleanup();
          int newCount=this.count - 1;
          AtomicReferenceArray<ReferenceEntry<K,V>> table=this.table;
          int index=hash & (table.length() - 1);
          ReferenceEntry<K,V> first=table.get(index);
          boolean createNewEntry=true;
          for (e=first; e != null; e=e.getNext()) {
            K entryKey=e.getKey();
            if (e.getHash() == hash && entryKey != null && map.keyEquivalence.equivalent(key,entryKey)) {
              ValueReference<K,V> valueReference=e.getValueReference();
              if (valueReference.isComputingReference()) {
                createNewEntry=false;
              }
 else {
                V value=getLiveValue(e);
                if (value != null) {
                  recordLockedRead(e);
                  statsCounter.recordHit();
                  return value;
                }
                enqueueNotification(entryKey,hash,value,RemovalCause.COLLECTED);
                evictionQueue.remove(e);
                expirationQueue.remove(e);
                this.count=newCount;
              }
              break;
            }
          }
          if (createNewEntry) {
            computingValueReference=new ComputingValueReference<K,V>(loader);
            if (e == null) {
              e=map.newEntry(key,hash,first);
              table.set(index,e);
            }
            e.setValueReference(computingValueReference);
          }
        }
  finally {
          unlock();
          postWriteCleanup();
        }
        if (computingValueReference != null) {
          V value=null;
          try {
            long start;
            long end;
synchronized (e) {
              start=System.nanoTime();
              value=computingValueReference.compute(key,hash);
              end=System.nanoTime();
            }
            if (value != null) {
              put(key,hash,value,true);
            }
            statsCounter.recordMiss();
            statsCounter.recordCreate(end - start);
            return value;
          }
  finally {
            if (value == null) {
              clearValue(key,hash,computingValueReference);
            }
          }
        }
      }
      checkState(!Thread.holdsLock(e),"Recursive computation");
      V value=e.getValueReference().waitForValue();
      if (value != null) {
        recordRead(e);
        statsCounter.recordMiss();
        return value;
      }
      continue outer;
    }
  }
  finally {
    postReadCleanup();
  }
}
