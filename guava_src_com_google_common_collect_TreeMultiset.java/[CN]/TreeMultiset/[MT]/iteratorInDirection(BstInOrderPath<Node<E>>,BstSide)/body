{
  final Iterator<BstInOrderPath<Node<E>>> pathIterator=new AbstractSequentialIterator<BstInOrderPath<Node<E>>>(start){
    @Override protected BstInOrderPath<Node<E>> computeNext(    BstInOrderPath<Node<E>> previous){
      if (!previous.hasNext(direction)) {
        return null;
      }
      BstInOrderPath<Node<E>> next=previous.next(direction);
      return range.contains(next.getTip().getKey()) ? next : null;
    }
  }
;
  return new Iterator<Entry<E>>(){
    ToRemove<E> toRemove=new ToRemove<E>();
    @Override public boolean hasNext(){
      return pathIterator.hasNext();
    }
    @Override public Entry<E> next(){
      BstInOrderPath<Node<E>> path=pathIterator.next();
      return new LiveEntry(toRemove.setAndGet(path.getTip().getKey()),path.getTip().elemCount());
    }
    @Override public void remove(){
      setCount(toRemove.getAndClear(),0);
    }
  }
;
}
