{
  LocalCacheInternalMap<Object,Object> map=makeMap(createCacheBuilder().concurrencyLevel(1).initialCapacity(1).maximumSize(SMALL_MAX_SIZE).expireAfterWrite(99999,SECONDS).removalListener(countingRemovalListener()));
  Segment<Object,Object> segment=map.segments[0];
  AtomicReferenceArray<ReferenceEntry<Object,Object>> table=segment.table;
  assertEquals(1,table.length());
  Object key=new Object();
  int hash=map.hash(key);
  DummyEntry<Object,Object> entry=DummyEntry.create(key,hash,null);
  LoadingValueReference<Object,Object> valueRef=new LoadingValueReference<Object,Object>();
  entry.setValueReference(valueRef);
  assertFalse(segment.removeLoadingValue(key,hash,valueRef));
  table.set(0,entry);
  assertTrue(segment.removeLoadingValue(key,hash,valueRef));
  assertTrue(map.removalNotificationQueue.isEmpty());
  assertEquals(0,segment.count);
  assertNull(table.get(0));
  Object value=new Object();
  DummyValueReference<Object,Object> previousRef=DummyValueReference.create(value,entry);
  valueRef=new LoadingValueReference<Object,Object>(previousRef);
  entry.setValueReference(valueRef);
  table.set(0,entry);
  segment.count=1;
  assertTrue(segment.removeLoadingValue(key,hash,valueRef));
  assertSame(entry,table.get(0));
  assertSame(value,segment.get(key,hash));
  table.set(0,entry);
  DummyValueReference<Object,Object> otherValueRef=DummyValueReference.create(value,entry);
  entry.setValueReference(otherValueRef);
  assertFalse(segment.removeLoadingValue(key,hash,valueRef));
  entry.setValueReference(valueRef);
  assertTrue(segment.removeLoadingValue(key,hash,valueRef));
}
