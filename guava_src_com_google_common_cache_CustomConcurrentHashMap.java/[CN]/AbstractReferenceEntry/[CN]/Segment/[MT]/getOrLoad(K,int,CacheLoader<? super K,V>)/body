{
  try {
    outer:     while (true) {
      ReferenceEntry<K,V> e=null;
      if (count != 0) {
        e=getEntry(key,hash);
        if (e != null) {
          V value=getLiveValue(e);
          if (value != null) {
            recordRead(e);
            statsCounter.recordHit();
            return value;
          }
        }
      }
      if (e == null || !e.getValueReference().isLoading()) {
        boolean createNewEntry=true;
        LoadingValueReference<K,V> loadingValueReference=null;
        lock();
        try {
          preWriteCleanup();
          int newCount=this.count - 1;
          AtomicReferenceArray<ReferenceEntry<K,V>> table=this.table;
          int index=hash & (table.length() - 1);
          ReferenceEntry<K,V> first=table.get(index);
          for (e=first; e != null; e=e.getNext()) {
            K entryKey=e.getKey();
            if (e.getHash() == hash && entryKey != null && map.keyEquivalence.equivalent(key,entryKey)) {
              ValueReference<K,V> valueReference=e.getValueReference();
              if (valueReference.isLoading()) {
                createNewEntry=false;
              }
 else {
                V value=valueReference.get();
                if (value == null) {
                  enqueueNotification(entryKey,hash,valueReference,RemovalCause.COLLECTED);
                }
 else                 if (map.expires() && map.isExpired(e)) {
                  enqueueNotification(entryKey,hash,valueReference,RemovalCause.EXPIRED);
                }
 else {
                  recordLockedRead(e);
                  statsCounter.recordHit();
                  return value;
                }
                evictionQueue.remove(e);
                expirationQueue.remove(e);
                this.count=newCount;
              }
              break;
            }
          }
          if (createNewEntry) {
            loadingValueReference=new LoadingValueReference<K,V>(loader);
            if (e == null) {
              e=newEntry(key,hash,first);
              e.setValueReference(loadingValueReference);
              table.set(index,e);
            }
 else {
              e.setValueReference(loadingValueReference);
            }
          }
        }
  finally {
          unlock();
          postWriteCleanup();
        }
        if (createNewEntry) {
          return load(key,hash,e,loadingValueReference);
        }
      }
      checkState(!Thread.holdsLock(e),"Recursive load");
      V value=e.getValueReference().waitForValue();
      if (value != null) {
        recordRead(e);
        statsCounter.recordConcurrentMiss();
        return value;
      }
      continue outer;
    }
  }
  finally {
    postReadCleanup();
  }
}
