{
  lock();
  try {
    if (expires) {
      expireEntries();
    }
    int newCount=this.count - 1;
    AtomicReferenceArray<ReferenceEntry<K,V>> table=this.table;
    int index=hash & (table.length() - 1);
    ReferenceEntry<K,V> first=table.get(index);
    for (ReferenceEntry<K,V> e=first; e != null; e=e.getNext()) {
      K entryKey=e.getKey();
      if (e.getHash() == hash && entryKey != null && keyEquivalence.equivalent(entryKey,key)) {
        V entryValue=e.getValueReference().get();
        if (value == entryValue || (value != null && entryValue != null && valueEquivalence.equivalent(entryValue,value))) {
          ++modCount;
          ReferenceEntry<K,V> newFirst=removeFromTable(first,e);
          table.set(index,newFirst);
          this.count=newCount;
          return true;
        }
 else {
          return false;
        }
      }
    }
    return false;
  }
  finally {
    unlock();
  }
}
