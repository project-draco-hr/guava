{
  checkNotNull(value);
  lock();
  try {
    if (expires) {
      expireEntries();
    }
    int newCount=this.count + 1;
    if (newCount > this.threshold) {
      expand();
    }
    AtomicReferenceArray<ReferenceEntry<K,V>> table=this.table;
    int index=hash & (table.length() - 1);
    ReferenceEntry<K,V> first=table.get(index);
    for (ReferenceEntry<K,V> e=first; e != null; e=e.getNext()) {
      K entryKey=e.getKey();
      if (e.getHash() == hash && entryKey != null && keyEquivalence.equivalent(key,entryKey)) {
        V entryValue=e.getValueReference().get();
        boolean absent=entryValue == null;
        if (onlyIfAbsent && !absent) {
          return entryValue;
        }
        setValue(e,value,absent);
        return entryValue;
      }
    }
    ++modCount;
    ReferenceEntry<K,V> newEntry=entryFactory.newEntry(CustomConcurrentHashMap.this,key,hash,first);
    setValue(newEntry,value,true);
    table.set(index,newEntry);
    this.count=newCount;
    return null;
  }
  finally {
    unlock();
  }
}
