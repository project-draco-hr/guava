{
  keyStrength=builder.getKeyStrength();
  valueStrength=builder.getValueStrength();
  keyEquivalence=builder.getKeyEquivalence();
  valueEquivalence=builder.getValueEquivalence();
  expireAfterAccessNanos=builder.getExpireAfterAccessNanos();
  expireAfterWriteNanos=builder.getExpireAfterWriteNanos();
  maximumSize=builder.maximumSize;
  boolean evictsBySize=evictsBySize();
  entryFactory=EntryFactory.getFactory(keyStrength,expires(),evictsBySize);
  MapEvictionListener<? super K,? super V> evictionListener=builder.evictionListener;
  if (evictionListener == null || evictionListener.equals(NullListener.INSTANCE)) {
    @SuppressWarnings("unchecked") Queue<ReferenceEntry<K,V>> defaultQueue=(Queue)discardingQueue;
    evictionNotificationQueue=defaultQueue;
    @SuppressWarnings("unchecked") MapEvictionListener<K,V> defaultListener=NullListener.INSTANCE;
    this.evictionListener=defaultListener;
  }
 else {
    evictionNotificationQueue=new ConcurrentLinkedQueue<ReferenceEntry<K,V>>();
    this.evictionListener=evictionListener;
  }
  concurrencyLevel=filterConcurrencyLevel(builder.getConcurrencyLevel());
  int initialCapacity=builder.getInitialCapacity();
  if (initialCapacity > MAXIMUM_CAPACITY) {
    initialCapacity=MAXIMUM_CAPACITY;
  }
  int segmentShift=0;
  int segmentCount=1;
  while (segmentCount < concurrencyLevel && (!evictsBySize || segmentCount * 2 <= maximumSize)) {
    ++segmentShift;
    segmentCount<<=1;
  }
  this.segmentShift=32 - segmentShift;
  segmentMask=segmentCount - 1;
  this.segments=newSegmentArray(segmentCount);
  int segmentCapacity=initialCapacity / segmentCount;
  if (segmentCapacity * segmentCount < initialCapacity) {
    ++segmentCapacity;
  }
  int segmentSize=1;
  while (segmentSize < segmentCapacity) {
    segmentSize<<=1;
  }
  if (evictsBySize) {
    int maximumSegmentSize=maximumSize / segmentCount + 1;
    int remainder=maximumSize % segmentCount;
    for (int i=0; i < this.segments.length; ++i) {
      if (i == remainder) {
        maximumSegmentSize--;
      }
      this.segments[i]=createSegment(segmentSize,maximumSegmentSize);
    }
  }
 else {
    for (int i=0; i < this.segments.length; ++i) {
      this.segments[i]=createSegment(segmentSize,MapMaker.UNSET_INT);
    }
  }
}
