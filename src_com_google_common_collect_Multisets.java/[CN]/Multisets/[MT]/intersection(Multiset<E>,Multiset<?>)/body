{
  checkNotNull(multiset1);
  checkNotNull(multiset2);
  return new AbstractMultiset<E>(){
    @Override public int count(    Object element){
      int count1=multiset1.count(element);
      return (count1 == 0) ? 0 : Math.min(count1,multiset2.count(element));
    }
    @Override Set<E> createElementSet(){
      return Sets.intersection(multiset1.elementSet(),multiset2.elementSet());
    }
    @Override public Set<Entry<E>> entrySet(){
      return entrySet;
    }
    final Set<Entry<E>> entrySet=new AbstractSet<Entry<E>>(){
      @Override public Iterator<Entry<E>> iterator(){
        final Iterator<Entry<E>> iterator1=multiset1.entrySet().iterator();
        return new AbstractIterator<Entry<E>>(){
          @Override protected Entry<E> computeNext(){
            while (iterator1.hasNext()) {
              Entry<E> entry1=iterator1.next();
              E element=entry1.getElement();
              int count=Math.min(entry1.getCount(),multiset2.count(element));
              if (count > 0) {
                return Multisets.immutableEntry(element,count);
              }
            }
            return endOfData();
          }
        }
;
      }
      @Override public int size(){
        return elementSet().size();
      }
      @Override public boolean contains(      Object o){
        if (o instanceof Entry) {
          Entry<?> entry=(Entry<?>)o;
          int entryCount=entry.getCount();
          return (entryCount > 0) && (count(entry.getElement()) == entryCount);
        }
        return false;
      }
      @Override public boolean isEmpty(){
        return elementSet().isEmpty();
      }
    }
;
  }
;
}
