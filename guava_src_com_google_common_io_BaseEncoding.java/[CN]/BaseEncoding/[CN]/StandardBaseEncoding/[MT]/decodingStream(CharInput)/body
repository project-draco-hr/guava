{
  checkNotNull(reader);
  return new ByteInput(){
    int bitBuffer=0;
    int bitBufferLength=0;
    int readChars=0;
    boolean hitPadding=false;
    final CharMatcher paddingMatcher=paddingMatcher();
    @Override public int read() throws IOException {
      while (true) {
        int readChar=reader.read();
        if (readChar == -1) {
          int charsOverChunk=readChars % charsPerChunk;
          if (!hitPadding && !validPadding[charsOverChunk]) {
            throw new IOException("Invalid input length " + readChars);
          }
          return -1;
        }
        readChars++;
        char ch=(char)readChar;
        if (paddingMatcher.matches(ch)) {
          if (!hitPadding && (readChars == 0 || !validPadding[(readChars - 1) % charsPerChunk])) {
            throw new IOException("Padding cannot start at index " + readChars);
          }
          hitPadding=true;
        }
 else         if (hitPadding) {
          throw new IOException("Expected padding character but found '" + ch + "' at index "+ readChars);
        }
 else         if (!CharMatcher.ASCII.matches(ch) || decodabet[ch] == -1) {
          throw new IOException("Unrecognized character: " + ch);
        }
 else {
          bitBuffer<<=bitsPerChar;
          bitBuffer|=decodabet[ch] & alphabetMask;
          bitBufferLength+=bitsPerChar;
          if (bitBufferLength >= 8) {
            bitBufferLength-=8;
            return (bitBuffer >> bitBufferLength) & 0xFF;
          }
        }
      }
    }
    @Override public void close() throws IOException {
      reader.close();
    }
  }
;
}
