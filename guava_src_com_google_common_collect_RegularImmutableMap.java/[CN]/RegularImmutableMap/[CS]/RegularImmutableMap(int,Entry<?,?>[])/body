{
  checkPositionIndex(size,theEntries.length);
  entries=createEntryArray(size);
  int tableSize=Hashing.closedTableSize(size,MAX_LOAD_FACTOR);
  table=createEntryArray(tableSize);
  mask=tableSize - 1;
  for (int entryIndex=0; entryIndex < size; entryIndex++) {
    @SuppressWarnings("unchecked") Entry<K,V> entry=(Entry<K,V>)theEntries[entryIndex];
    K key=entry.getKey();
    V value=entry.getValue();
    checkEntryNotNull(key,value);
    int tableIndex=Hashing.smear(key.hashCode()) & mask;
    @Nullable ImmutableMapEntry<K,V> existing=table[tableIndex];
    ImmutableMapEntry<K,V> newEntry;
    if (existing == null) {
      boolean reusable=entry instanceof ImmutableMapEntry && ((ImmutableMapEntry<K,V>)entry).isReusable();
      newEntry=reusable ? (ImmutableMapEntry<K,V>)entry : new ImmutableMapEntry<K,V>(key,value);
    }
 else {
      newEntry=new NonTerminalImmutableMapEntry<K,V>(key,value,existing);
    }
    table[tableIndex]=newEntry;
    entries[entryIndex]=newEntry;
    checkNoConflictInKeyBucket(key,newEntry,existing);
  }
}
