{
  final Iterator<BstInOrderPath<Node<E>>> pathIterator=new AbstractLinkedIterator<BstInOrderPath<Node<E>>>(start){
    @Override protected BstInOrderPath<Node<E>> computeNext(    BstInOrderPath<Node<E>> previous){
      if (!previous.hasNext(direction)) {
        return null;
      }
      BstInOrderPath<Node<E>> next=previous.next(direction);
      return range.contains(next.getTip().getKey()) ? next : null;
    }
  }
;
  return new Iterator<Entry<E>>(){
    E toRemove=null;
    @Override public boolean hasNext(){
      return pathIterator.hasNext();
    }
    @Override public Entry<E> next(){
      BstInOrderPath<Node<E>> path=pathIterator.next();
      return new LiveEntry(toRemove=path.getTip().getKey(),path.getTip().elemCount());
    }
    @Override public void remove(){
      checkState(toRemove != null);
      setCount(toRemove,0);
      toRemove=null;
    }
  }
;
}
