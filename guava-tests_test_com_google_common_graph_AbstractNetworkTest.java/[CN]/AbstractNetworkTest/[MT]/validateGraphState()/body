{
  new EqualsTester().addEqualityGroup(graph,Graphs.copyOf(graph),ImmutableNetwork.copyOf(graph)).testEquals();
  String graphString=graph.toString();
  assertThat(graphString).contains("isDirected: " + graph.isDirected());
  assertThat(graphString).contains("allowsParallelEdges: " + graph.allowsParallelEdges());
  assertThat(graphString).contains("allowsSelfLoops: " + graph.allowsSelfLoops());
  int nodeStart=graphString.indexOf("nodes:");
  int edgeStart=graphString.indexOf("edges:");
  String nodeString=graphString.substring(nodeStart,edgeStart);
  String edgeString=graphString.substring(edgeStart);
  for (  String edge : graph.edges()) {
    assertThat(edgeString).contains(edge);
    if (!(graph instanceof Hypergraph)) {
      Iterator<Integer> incidentNodesIterator=graph.incidentNodes(edge).iterator();
      Integer node1=incidentNodesIterator.next();
      Integer node2=incidentNodesIterator.hasNext() ? incidentNodesIterator.next() : node1;
      assertFalse(incidentNodesIterator.hasNext());
      assertThat(graph.edgesConnecting(node1,node2)).contains(edge);
      assertThat(graph.successors(node1)).contains(node2);
      assertThat(graph.adjacentNodes(node1)).contains(node2);
      assertThat(graph.outEdges(node1)).contains(edge);
      assertThat(graph.incidentEdges(node1)).contains(edge);
      assertThat(graph.predecessors(node2)).contains(node1);
      assertThat(graph.adjacentNodes(node2)).contains(node1);
      assertThat(graph.inEdges(node2)).contains(edge);
      assertThat(graph.incidentEdges(node2)).contains(edge);
    }
    for (    Integer incidentNode : graph.incidentNodes(edge)) {
      assertThat(graph.nodes()).contains(incidentNode);
      for (      String adjacentEdge : graph.incidentEdges(incidentNode)) {
        assertTrue(edge.equals(adjacentEdge) || graph.adjacentEdges(edge).contains(adjacentEdge));
      }
    }
  }
  for (  Integer node : graph.nodes()) {
    assertThat(nodeString).contains(node.toString());
    for (    String incidentEdge : graph.incidentEdges(node)) {
      assertTrue(graph.inEdges(node).contains(incidentEdge) || graph.outEdges(node).contains(incidentEdge));
      assertThat(graph.edges()).contains(incidentEdge);
      assertThat(graph.incidentNodes(incidentEdge)).contains(node);
    }
    for (    String inEdge : graph.inEdges(node)) {
      assertThat(graph.incidentEdges(node)).contains(inEdge);
      if (!(graph instanceof Hypergraph)) {
        assertThat(graph.outEdges(Graphs.oppositeNode(graph,inEdge,node))).contains(inEdge);
      }
    }
    for (    String outEdge : graph.outEdges(node)) {
      assertThat(graph.incidentEdges(node)).contains(outEdge);
      if (!(graph instanceof Hypergraph)) {
        assertThat(graph.inEdges(Graphs.oppositeNode(graph,outEdge,node))).contains(outEdge);
      }
    }
    for (    Integer adjacentNode : graph.adjacentNodes(node)) {
      assertTrue(graph.predecessors(node).contains(adjacentNode) || graph.successors(node).contains(adjacentNode));
      assertTrue(!graph.edgesConnecting(node,adjacentNode).isEmpty() || !graph.edgesConnecting(adjacentNode,node).isEmpty());
      assertThat(graph.incidentEdges(node)).isNotEmpty();
      assertThat(graph.incidentEdges(node)).hasSize(graph.degree(node));
    }
    for (    Integer predecessor : graph.predecessors(node)) {
      assertThat(graph.successors(predecessor)).contains(node);
      assertThat(graph.edgesConnecting(predecessor,node)).isNotEmpty();
      assertThat(graph.inEdges(node)).isNotEmpty();
      assertThat(graph.inEdges(node)).hasSize(graph.inDegree(node));
    }
    for (    Integer successor : graph.successors(node)) {
      assertThat(graph.predecessors(successor)).contains(node);
      assertThat(graph.edgesConnecting(node,successor)).isNotEmpty();
      assertThat(graph.outEdges(node)).isNotEmpty();
      assertThat(graph.outEdges(node)).hasSize(graph.outDegree(node));
    }
  }
}
