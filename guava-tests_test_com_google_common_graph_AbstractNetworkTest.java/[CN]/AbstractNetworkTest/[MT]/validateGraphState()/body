{
  new EqualsTester().addEqualityGroup(graph,Graphs.copyOf(graph),ImmutableNetwork.copyOf(graph)).testEquals();
  String graphString=graph.toString();
  assertThat(graphString).contains("isDirected: " + graph.isDirected());
  assertThat(graphString).contains("allowsParallelEdges: " + graph.allowsParallelEdges());
  assertThat(graphString).contains("allowsSelfLoops: " + graph.allowsSelfLoops());
  int nodeStart=graphString.indexOf("nodes:");
  int edgeStart=graphString.indexOf("edges:");
  String nodeString=graphString.substring(nodeStart,edgeStart);
  String edgeString=graphString.substring(edgeStart);
  for (  String edge : graph.edges()) {
    assertThat(edgeString).contains(edge);
    Endpoints<Integer> endpoints=graph.incidentNodes(edge);
    Integer nodeA=endpoints.nodeA();
    Integer nodeB=endpoints.nodeB();
    assertThat(graph.edgesConnecting(nodeA,nodeB)).contains(edge);
    assertThat(graph.successors(nodeA)).contains(nodeB);
    assertThat(graph.adjacentNodes(nodeA)).contains(nodeB);
    assertThat(graph.outEdges(nodeA)).contains(edge);
    assertThat(graph.incidentEdges(nodeA)).contains(edge);
    assertThat(graph.predecessors(nodeB)).contains(nodeA);
    assertThat(graph.adjacentNodes(nodeB)).contains(nodeA);
    assertThat(graph.inEdges(nodeB)).contains(edge);
    assertThat(graph.incidentEdges(nodeB)).contains(edge);
    for (    Integer incidentNode : graph.incidentNodes(edge)) {
      assertThat(graph.nodes()).contains(incidentNode);
      for (      String adjacentEdge : graph.incidentEdges(incidentNode)) {
        assertTrue(edge.equals(adjacentEdge) || graph.adjacentEdges(edge).contains(adjacentEdge));
      }
    }
  }
  for (  Integer node : graph.nodes()) {
    assertThat(nodeString).contains(node.toString());
    for (    String incidentEdge : graph.incidentEdges(node)) {
      assertTrue(graph.inEdges(node).contains(incidentEdge) || graph.outEdges(node).contains(incidentEdge));
      assertThat(graph.edges()).contains(incidentEdge);
      assertThat(graph.incidentNodes(incidentEdge)).contains(node);
    }
    for (    String inEdge : graph.inEdges(node)) {
      assertThat(graph.incidentEdges(node)).contains(inEdge);
      assertThat(graph.outEdges(Graphs.oppositeNode(graph,inEdge,node))).contains(inEdge);
    }
    for (    String outEdge : graph.outEdges(node)) {
      assertThat(graph.incidentEdges(node)).contains(outEdge);
      assertThat(graph.inEdges(Graphs.oppositeNode(graph,outEdge,node))).contains(outEdge);
    }
    for (    Integer adjacentNode : graph.adjacentNodes(node)) {
      assertTrue(graph.predecessors(node).contains(adjacentNode) || graph.successors(node).contains(adjacentNode));
      assertTrue(!graph.edgesConnecting(node,adjacentNode).isEmpty() || !graph.edgesConnecting(adjacentNode,node).isEmpty());
      assertThat(graph.incidentEdges(node)).isNotEmpty();
      assertThat(graph.incidentEdges(node)).hasSize(graph.degree(node));
    }
    for (    Integer predecessor : graph.predecessors(node)) {
      assertThat(graph.successors(predecessor)).contains(node);
      assertThat(graph.edgesConnecting(predecessor,node)).isNotEmpty();
      assertThat(graph.inEdges(node)).isNotEmpty();
      assertThat(graph.inEdges(node)).hasSize(graph.inDegree(node));
    }
    for (    Integer successor : graph.successors(node)) {
      assertThat(graph.predecessors(successor)).contains(node);
      assertThat(graph.edgesConnecting(node,successor)).isNotEmpty();
      assertThat(graph.outEdges(node)).isNotEmpty();
      assertThat(graph.outEdges(node)).hasSize(graph.outDegree(node));
    }
  }
}
