{
  new EqualsTester().addEqualityGroup(network,Graphs.copyOf(network),ImmutableNetwork.copyOf(network)).testEquals();
  String networkString=network.toString();
  assertThat(networkString).contains("isDirected: " + network.isDirected());
  assertThat(networkString).contains("allowsParallelEdges: " + network.allowsParallelEdges());
  assertThat(networkString).contains("allowsSelfLoops: " + network.allowsSelfLoops());
  int nodeStart=networkString.indexOf("nodes:");
  int edgeStart=networkString.indexOf("edges:");
  String nodeString=networkString.substring(nodeStart,edgeStart);
  String edgeString=networkString.substring(edgeStart);
  Graph<N,Set<E>> asGraph=network.asGraph();
  AbstractGraphTest.validateGraph(asGraph);
  assertThat(network.nodes()).isEqualTo(asGraph.nodes());
  assertThat(network.edges().size()).isAtLeast(asGraph.edges().size());
  assertThat(network.nodeOrder()).isEqualTo(asGraph.nodeOrder());
  assertThat(network.isDirected()).isEqualTo(asGraph.isDirected());
  assertThat(network.allowsSelfLoops()).isEqualTo(asGraph.allowsSelfLoops());
  sanityCheckCollection(network.nodes());
  sanityCheckCollection(network.edges());
  sanityCheckCollection(asGraph.edges());
  for (  E edge : network.edges()) {
    assertThat(edgeString).contains(edge.toString());
    Endpoints<N> endpoints=network.incidentNodes(edge);
    N nodeA=endpoints.nodeA();
    N nodeB=endpoints.nodeB();
    assertThat(asGraph.edges()).contains(Endpoints.of(network,nodeA,nodeB));
    assertThat(network.edgesConnecting(nodeA,nodeB)).contains(edge);
    assertThat(network.successors(nodeA)).contains(nodeB);
    assertThat(network.adjacentNodes(nodeA)).contains(nodeB);
    assertThat(network.outEdges(nodeA)).contains(edge);
    assertThat(network.incidentEdges(nodeA)).contains(edge);
    assertThat(network.predecessors(nodeB)).contains(nodeA);
    assertThat(network.adjacentNodes(nodeB)).contains(nodeA);
    assertThat(network.inEdges(nodeB)).contains(edge);
    assertThat(network.incidentEdges(nodeB)).contains(edge);
    for (    N incidentNode : ImmutableSet.of(network.incidentNodes(edge).nodeA(),network.incidentNodes(edge).nodeB())) {
      assertThat(network.nodes()).contains(incidentNode);
      for (      E adjacentEdge : network.incidentEdges(incidentNode)) {
        assertTrue(edge.equals(adjacentEdge) || Graphs.adjacentEdges(network,edge).contains(adjacentEdge));
      }
    }
  }
  for (  N node : network.nodes()) {
    assertThat(nodeString).contains(node.toString());
    assertThat(network.adjacentNodes(node)).isEqualTo(asGraph.adjacentNodes(node));
    assertThat(network.predecessors(node)).isEqualTo(asGraph.predecessors(node));
    assertThat(network.successors(node)).isEqualTo(asGraph.successors(node));
    sanityCheckCollection(network.adjacentNodes(node));
    sanityCheckCollection(network.predecessors(node));
    sanityCheckCollection(network.successors(node));
    sanityCheckCollection(network.incidentEdges(node));
    sanityCheckCollection(network.inEdges(node));
    sanityCheckCollection(network.outEdges(node));
    if (network.isDirected()) {
      assertThat(network.degree(node)).isEqualTo(network.inEdges(node).size() + network.outEdges(node).size());
      assertThat(network.inDegree(node)).isEqualTo(network.inEdges(node).size());
      assertThat(network.outDegree(node)).isEqualTo(network.outEdges(node).size());
    }
 else {
      assertThat(network.degree(node)).isEqualTo(network.incidentEdges(node).size() + network.edgesConnecting(node,node).size());
      assertThat(network.inDegree(node)).isEqualTo(network.degree(node));
      assertThat(network.outDegree(node)).isEqualTo(network.degree(node));
    }
    for (    N otherNode : network.nodes()) {
      Set<E> edgesConnecting=network.edgesConnecting(node,otherNode);
      boolean isSelfLoop=node.equals(otherNode);
      if (network.isDirected() || !isSelfLoop) {
        assertThat(edgesConnecting).isEqualTo(Sets.intersection(network.outEdges(node),network.inEdges(otherNode)));
      }
      if (!network.allowsParallelEdges()) {
        assertThat(edgesConnecting.size()).isAtMost(1);
      }
      if (!network.allowsSelfLoops() && isSelfLoop) {
        assertThat(edgesConnecting).isEmpty();
      }
      for (      E edge : edgesConnecting) {
        assertThat(network.incidentNodes(edge)).isEqualTo(Endpoints.of(network,node,otherNode));
      }
    }
    for (    E incidentEdge : network.incidentEdges(node)) {
      assertTrue(network.inEdges(node).contains(incidentEdge) || network.outEdges(node).contains(incidentEdge));
      assertThat(network.edges()).contains(incidentEdge);
      assertTrue(network.incidentNodes(incidentEdge).nodeA().equals(node) || network.incidentNodes(incidentEdge).nodeB().equals(node));
    }
    for (    E inEdge : network.inEdges(node)) {
      assertThat(network.incidentEdges(node)).contains(inEdge);
      assertThat(network.outEdges(network.incidentNodes(inEdge).adjacentNode(node))).contains(inEdge);
    }
    for (    E outEdge : network.outEdges(node)) {
      assertThat(network.incidentEdges(node)).contains(outEdge);
      assertThat(network.inEdges(network.incidentNodes(outEdge).adjacentNode(node))).contains(outEdge);
    }
    for (    N adjacentNode : network.adjacentNodes(node)) {
      assertTrue(network.predecessors(node).contains(adjacentNode) || network.successors(node).contains(adjacentNode));
      assertTrue(!network.edgesConnecting(node,adjacentNode).isEmpty() || !network.edgesConnecting(adjacentNode,node).isEmpty());
    }
    for (    N predecessor : network.predecessors(node)) {
      assertThat(network.successors(predecessor)).contains(node);
      assertThat(network.edgesConnecting(predecessor,node)).isNotEmpty();
    }
    for (    N successor : network.successors(node)) {
      Set<E> edgesConnecting=network.edgesConnecting(node,successor);
      assertThat(network.predecessors(successor)).contains(node);
      assertThat(edgesConnecting).isNotEmpty();
      assertThat(edgesConnecting).isEqualTo(asGraph.edgeValue(node,successor));
    }
  }
}
