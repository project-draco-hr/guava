{
  assertStronglyEquivalent(network,Graphs.copyOf(network));
  assertStronglyEquivalent(network,ImmutableNetwork.copyOf(network));
  String networkString=network.toString();
  assertThat(networkString).contains("isDirected: " + network.isDirected());
  assertThat(networkString).contains("allowsParallelEdges: " + network.allowsParallelEdges());
  assertThat(networkString).contains("allowsSelfLoops: " + network.allowsSelfLoops());
  int nodeStart=networkString.indexOf("nodes:");
  int edgeStart=networkString.indexOf("edges:");
  String nodeString=networkString.substring(nodeStart,edgeStart);
  String edgeString=networkString.substring(edgeStart);
  Graph<N> asGraph=network.asGraph();
  AbstractGraphTest.validateGraph(asGraph);
  assertThat(network.nodes()).isEqualTo(asGraph.nodes());
  assertThat(network.edges().size()).isAtLeast(asGraph.edges().size());
  assertThat(network.nodeOrder()).isEqualTo(asGraph.nodeOrder());
  assertThat(network.isDirected()).isEqualTo(asGraph.isDirected());
  assertThat(network.allowsSelfLoops()).isEqualTo(asGraph.allowsSelfLoops());
  sanityCheckCollection(network.nodes());
  sanityCheckCollection(network.edges());
  sanityCheckCollection(asGraph.edges());
  for (  E edge : network.edges()) {
    assertThat(edgeString).contains(edge.toString());
    EndpointPair<N> endpointPair=network.incidentNodes(edge);
    N nodeU=endpointPair.nodeU();
    N nodeV=endpointPair.nodeV();
    assertThat(asGraph.edges()).contains(EndpointPair.of(network,nodeU,nodeV));
    assertThat(network.edgesConnecting(nodeU,nodeV)).contains(edge);
    assertThat(network.successors(nodeU)).contains(nodeV);
    assertThat(network.adjacentNodes(nodeU)).contains(nodeV);
    assertThat(network.outEdges(nodeU)).contains(edge);
    assertThat(network.incidentEdges(nodeU)).contains(edge);
    assertThat(network.predecessors(nodeV)).contains(nodeU);
    assertThat(network.adjacentNodes(nodeV)).contains(nodeU);
    assertThat(network.inEdges(nodeV)).contains(edge);
    assertThat(network.incidentEdges(nodeV)).contains(edge);
    for (    N incidentNode : network.incidentNodes(edge)) {
      assertThat(network.nodes()).contains(incidentNode);
      for (      E adjacentEdge : network.incidentEdges(incidentNode)) {
        assertTrue(edge.equals(adjacentEdge) || network.adjacentEdges(edge).contains(adjacentEdge));
      }
    }
  }
  for (  N node : network.nodes()) {
    assertThat(nodeString).contains(node.toString());
    assertThat(network.adjacentNodes(node)).isEqualTo(asGraph.adjacentNodes(node));
    assertThat(network.predecessors(node)).isEqualTo(asGraph.predecessors(node));
    assertThat(network.successors(node)).isEqualTo(asGraph.successors(node));
    sanityCheckCollection(network.adjacentNodes(node));
    sanityCheckCollection(network.predecessors(node));
    sanityCheckCollection(network.successors(node));
    sanityCheckCollection(network.incidentEdges(node));
    sanityCheckCollection(network.inEdges(node));
    sanityCheckCollection(network.outEdges(node));
    if (network.isDirected()) {
      assertThat(network.degree(node)).isEqualTo(network.inEdges(node).size() + network.outEdges(node).size());
      assertThat(network.inDegree(node)).isEqualTo(network.inEdges(node).size());
      assertThat(network.outDegree(node)).isEqualTo(network.outEdges(node).size());
    }
 else {
      assertThat(network.degree(node)).isEqualTo(network.incidentEdges(node).size() + network.edgesConnecting(node,node).size());
      assertThat(network.inDegree(node)).isEqualTo(network.degree(node));
      assertThat(network.outDegree(node)).isEqualTo(network.degree(node));
    }
    for (    N otherNode : network.nodes()) {
      Set<E> edgesConnecting=network.edgesConnecting(node,otherNode);
      boolean isSelfLoop=node.equals(otherNode);
      if (network.isDirected() || !isSelfLoop) {
        assertThat(edgesConnecting).isEqualTo(Sets.intersection(network.outEdges(node),network.inEdges(otherNode)));
      }
      if (!network.allowsParallelEdges()) {
        assertThat(edgesConnecting.size()).isAtMost(1);
      }
      if (!network.allowsSelfLoops() && isSelfLoop) {
        assertThat(edgesConnecting).isEmpty();
      }
      for (      E edge : edgesConnecting) {
        assertThat(network.incidentNodes(edge)).isEqualTo(EndpointPair.of(network,node,otherNode));
      }
    }
    for (    E incidentEdge : network.incidentEdges(node)) {
      assertTrue(network.inEdges(node).contains(incidentEdge) || network.outEdges(node).contains(incidentEdge));
      assertThat(network.edges()).contains(incidentEdge);
      assertTrue(network.incidentNodes(incidentEdge).nodeU().equals(node) || network.incidentNodes(incidentEdge).nodeV().equals(node));
    }
    for (    E inEdge : network.inEdges(node)) {
      assertThat(network.incidentEdges(node)).contains(inEdge);
      assertThat(network.outEdges(network.incidentNodes(inEdge).adjacentNode(node))).contains(inEdge);
    }
    for (    E outEdge : network.outEdges(node)) {
      assertThat(network.incidentEdges(node)).contains(outEdge);
      assertThat(network.inEdges(network.incidentNodes(outEdge).adjacentNode(node))).contains(outEdge);
    }
    for (    N adjacentNode : network.adjacentNodes(node)) {
      assertTrue(network.predecessors(node).contains(adjacentNode) || network.successors(node).contains(adjacentNode));
      assertTrue(!network.edgesConnecting(node,adjacentNode).isEmpty() || !network.edgesConnecting(adjacentNode,node).isEmpty());
    }
    for (    N predecessor : network.predecessors(node)) {
      assertThat(network.successors(predecessor)).contains(node);
      assertThat(network.edgesConnecting(predecessor,node)).isNotEmpty();
    }
    for (    N successor : network.successors(node)) {
      assertThat(network.predecessors(successor)).contains(node);
      assertThat(network.edgesConnecting(node,successor)).isNotEmpty();
    }
  }
}
