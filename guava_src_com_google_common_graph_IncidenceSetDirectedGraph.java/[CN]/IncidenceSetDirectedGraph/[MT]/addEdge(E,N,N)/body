{
  checkNotNull(edge,"edge");
  checkNotNull(node1,"node1");
  checkNotNull(node2,"node2");
  checkArgument(config.isSelfLoopsAllowed() || !node1.equals(node2),SELF_LOOPS_NOT_ALLOWED,node1);
  IncidentNodes<N> endpoints=edgeToIncidentNodes.get(edge);
  if (endpoints != null) {
    N source=endpoints.source();
    N target=endpoints.target();
    checkArgument(source.equals(node1) && target.equals(node2),REUSING_EDGE,edge,ImmutableList.of(source,target),ImmutableList.of(node1,node2));
    return false;
  }
 else   if (!config.isMultigraph() && containsNode(node1) && containsNode(node2)) {
    E edgeConnecting=Iterables.getOnlyElement(edgesConnecting(node1,node2),null);
    checkArgument(edgeConnecting == null,ADDING_PARALLEL_EDGE,node1,node2,edgeConnecting);
  }
  addNode(node1);
  addNode(node2);
  edgeToIncidentNodes.put(edge,IncidentNodes.of(node1,node2));
  nodeToIncidentEdges.get(node1).outEdges().add(edge);
  nodeToIncidentEdges.get(node2).inEdges().add(edge);
  return true;
}
