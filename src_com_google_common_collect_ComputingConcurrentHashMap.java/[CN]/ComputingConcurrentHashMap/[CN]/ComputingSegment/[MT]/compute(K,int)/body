{
  outer:   while (true) {
    V value=get(key,hash);
    if (value != null) {
      return value;
    }
    ReferenceEntry<K,V> entry=null;
    ComputingValueReference computingValueReference=null;
    lock();
    try {
      preWriteCleanup();
      AtomicReferenceArray<ReferenceEntry<K,V>> table=this.table;
      int index=hash & (table.length() - 1);
      ReferenceEntry<K,V> first=table.get(index);
      for (ReferenceEntry<K,V> e=first; e != null; e=e.getNext()) {
        K entryKey=e.getKey();
        if (e.getHash() == hash && entryKey != null && keyEquivalence.equivalent(key,entryKey)) {
          entry=e;
          ValueReference<K,V> valueReference=entry.getValueReference();
          value=valueReference.get();
          if (value != null) {
            return value;
          }
          if (!valueReference.isComputingReference()) {
            unsetLiveEntry(entry,hash);
          }
          break;
        }
      }
      if (entry == null || isUnset(entry)) {
        computingValueReference=new ComputingValueReference();
        if (entry == null) {
          entry=entryFactory.newEntry(ComputingConcurrentHashMap.this,key,hash,first);
          table.set(index,entry);
        }
        entry.setValueReference(computingValueReference);
      }
    }
  finally {
      unlock();
      postWriteCleanup();
    }
    if (computingValueReference != null) {
      boolean success=false;
      try {
synchronized (entry) {
          value=computingValueReference.compute(key,hash);
        }
        checkNotNull(value,"compute() returned null unexpectedly");
        return value;
      }
  finally {
        if (value == null) {
          clearValue(key,hash,computingValueReference);
        }
      }
    }
    boolean interrupted=false;
    try {
      while (true) {
        try {
          checkState(!Thread.holdsLock(entry),"Recursive computation");
          value=entry.getValueReference().waitForValue();
          if (value == null) {
            continue outer;
          }
          recordRead(entry);
          return value;
        }
 catch (        InterruptedException e) {
          interrupted=true;
        }
      }
    }
  finally {
      if (interrupted) {
        Thread.currentThread().interrupt();
      }
    }
  }
}
