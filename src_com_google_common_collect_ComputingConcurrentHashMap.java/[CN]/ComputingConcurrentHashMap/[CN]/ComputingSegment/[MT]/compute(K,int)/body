{
  outer:   while (true) {
    ReferenceEntry<K,V> entry=getLiveEntry(key,hash);
    if (entry != null) {
      V value=entry.getValueReference().get();
      if (value != null) {
        return value;
      }
    }
    ComputingValueReference computingValueReference=null;
    lock();
    try {
      expireEntries();
      processPendingCleanup();
      AtomicReferenceArray<ReferenceEntry<K,V>> table=this.table;
      int index=hash & (table.length() - 1);
      ReferenceEntry<K,V> first=table.get(index);
      for (ReferenceEntry<K,V> e=first; e != null; e=e.getNext()) {
        K entryKey=e.getKey();
        if (e.getHash() == hash && entryKey != null && keyEquivalence.equivalent(key,entryKey)) {
          entry=e;
          break;
        }
      }
      if (entry == null || isInvalid(entry)) {
        computingValueReference=new ComputingValueReference();
        if (entry == null) {
          entry=entryFactory.newEntry(ComputingConcurrentHashMap.this,key,hash,first);
          table.set(index,entry);
        }
        entry.setValueReference(computingValueReference);
      }
    }
  finally {
      unlock();
      scheduleCleanup();
    }
    if (computingValueReference != null) {
      boolean success=false;
      try {
        V value=null;
synchronized (entry) {
          value=computingValueReference.compute(key,hash);
        }
        checkNotNull(value,"compute() returned null unexpectedly");
        success=true;
        return value;
      }
  finally {
        if (!success) {
          clearValue(key,hash,computingValueReference);
          scheduleCleanup();
        }
      }
    }
    boolean interrupted=false;
    try {
      while (true) {
        try {
          checkState(!Thread.holdsLock(entry),"Recursive computation");
          V value=entry.getValueReference().waitForValue();
          if (value == null) {
            continue outer;
          }
          recordRead(entry);
          return value;
        }
 catch (        InterruptedException e) {
          interrupted=true;
        }
      }
    }
  finally {
      if (interrupted) {
        Thread.currentThread().interrupt();
      }
    }
  }
}
