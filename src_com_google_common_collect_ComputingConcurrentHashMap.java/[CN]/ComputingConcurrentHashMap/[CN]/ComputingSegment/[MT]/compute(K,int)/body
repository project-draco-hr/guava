{
  outer:   while (true) {
    ReferenceEntry<K,V> entry=getLiveEntry(key,hash);
    if (entry == null) {
      ComputingValueReference computingValueReference=null;
      lock();
      try {
        expireEntries();
        int newCount=this.count + 1;
        if (newCount > this.threshold) {
          expand();
        }
        AtomicReferenceArray<ReferenceEntry<K,V>> table=this.table;
        int index=hash & (table.length() - 1);
        ReferenceEntry<K,V> first=table.get(index);
        for (ReferenceEntry<K,V> e=first; e != null; e=e.getNext()) {
          K entryKey=e.getKey();
          if (e.getHash() == hash && entryKey != null && keyEquivalence.equivalent(key,entryKey)) {
            entry=e;
            break;
          }
        }
        if (entry == null || isInvalid(entry)) {
          computingValueReference=new ComputingValueReference();
          if (evictEntries()) {
            newCount=this.count + 1;
            first=table.get(index);
          }
          ++modCount;
          if (entry == null) {
            entry=entryFactory.newEntry(ComputingConcurrentHashMap.this,key,hash,first);
            table.set(index,entry);
          }
          recordWrite(entry);
          entry.setValueReference(computingValueReference);
          this.count=newCount;
        }
 else {
          recordRead(entry);
        }
      }
  finally {
        unlock();
        scheduleCleanup();
      }
      if (computingValueReference != null) {
        boolean success=false;
        try {
          V value=null;
synchronized (entry) {
            value=computingValueReference.compute(key,hash);
          }
          checkNotNull(value,"compute() returned null unexpectedly");
          success=true;
          return value;
        }
  finally {
          if (!success) {
            clearValue(key,hash,computingValueReference);
            scheduleCleanup();
          }
        }
      }
    }
    boolean interrupted=false;
    try {
      while (true) {
        try {
          checkState(!Thread.holdsLock(entry),"Recursive computation");
          ValueReference<K,V> valueReference=entry.getValueReference();
          V value=valueReference.waitForValue();
          if (value == null) {
            clearValue(key,hash,valueReference);
            scheduleCleanup();
            continue outer;
          }
          return value;
        }
 catch (        InterruptedException e) {
          interrupted=true;
        }
      }
    }
  finally {
      if (interrupted) {
        Thread.currentThread().interrupt();
      }
    }
  }
}
