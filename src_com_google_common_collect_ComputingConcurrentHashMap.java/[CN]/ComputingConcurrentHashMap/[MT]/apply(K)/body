{
  checkNotNull(key);
  int hash=hash(key);
  Segment segment=segmentFor(hash);
  outer:   while (true) {
    ReferenceEntry<K,V> entry=segment.getEntry(key,hash);
    if (entry == null) {
      boolean created=false;
      segment.lock();
      try {
        if (expires) {
          segment.expireEntries();
        }
        entry=segment.getEntry(key,hash);
        if (entry == null) {
          created=true;
          int count=segment.count;
          if (count++ > segment.threshold) {
            segment.expand();
          }
          AtomicReferenceArray<ReferenceEntry<K,V>> table=segment.table;
          int index=hash & (table.length() - 1);
          ReferenceEntry<K,V> first=table.get(index);
          ++segment.modCount;
          entry=entryFactory.newEntry(this,key,hash,first);
          table.set(index,entry);
          segment.count=count;
        }
      }
  finally {
        segment.unlock();
      }
      if (created) {
        boolean success=false;
        try {
          V value=compute(segment,key,entry);
          checkNotNull(value,"compute() returned null unexpectedly");
          success=true;
          return value;
        }
  finally {
          if (!success) {
            segment.removeEntry(entry,hash);
          }
        }
      }
    }
    boolean interrupted=false;
    try {
      while (true) {
        try {
          V value=waitForValue(entry);
          if (value == null) {
            segment.removeEntry(entry,hash);
            continue outer;
          }
          return value;
        }
 catch (        InterruptedException e) {
          interrupted=true;
        }
      }
    }
  finally {
      if (interrupted) {
        Thread.currentThread().interrupt();
      }
    }
  }
}
