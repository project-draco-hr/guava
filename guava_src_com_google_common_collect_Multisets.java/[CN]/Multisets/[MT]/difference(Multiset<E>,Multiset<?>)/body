{
  checkNotNull(multiset1);
  checkNotNull(multiset2);
  return new AbstractMultiset<E>(){
    @Override public int count(    @Nullable Object element){
      int count1=multiset1.count(element);
      return (count1 == 0) ? 0 : Math.max(0,count1 - multiset2.count(element));
    }
    @Override Set<E> createElementSet(){
      return new Sets.ImprovedAbstractSet<E>(){
        @Override public Iterator<E> iterator(){
          return Iterators.transform(entryIterator(),new Function<Entry<E>,E>(){
            @Override public E apply(            Entry<E> input){
              return input.getElement();
            }
          }
);
        }
        @Override public boolean contains(        @Nullable Object o){
          return count(o) > 0;
        }
        @Override public int size(){
          return Iterators.size(iterator());
        }
      }
;
    }
    @Override Iterator<Entry<E>> entryIterator(){
      final Iterator<Entry<E>> iterator1=multiset1.entrySet().iterator();
      return new AbstractIterator<Entry<E>>(){
        @Override protected Entry<E> computeNext(){
          while (iterator1.hasNext()) {
            Entry<E> entry1=iterator1.next();
            E element=entry1.getElement();
            int count=Math.max(0,entry1.getCount() - multiset2.count(element));
            if (count > 0) {
              return immutableEntry(element,count);
            }
          }
          return endOfData();
        }
      }
;
    }
    @Override int distinctElements(){
      return elementSet().size();
    }
  }
;
}
