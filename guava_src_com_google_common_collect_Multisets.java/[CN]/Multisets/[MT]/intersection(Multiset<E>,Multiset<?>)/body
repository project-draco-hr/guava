{
  checkNotNull(multiset1);
  checkNotNull(multiset2);
  return new AbstractMultiset<E>(){
    @Override public int count(    Object element){
      int count1=multiset1.count(element);
      return (count1 == 0) ? 0 : Math.min(count1,multiset2.count(element));
    }
    @Override Set<E> createElementSet(){
      return Sets.intersection(multiset1.elementSet(),multiset2.elementSet());
    }
    private transient Set<Entry<E>> entrySet;
    @Override public Set<Entry<E>> entrySet(){
      Set<Entry<E>> result=entrySet;
      if (result == null) {
        final Multiset<E> self=this;
        return entrySet=new Multisets.EntrySet<E>(){
          @Override Multiset<E> multiset(){
            return self;
          }
          @Override public Iterator<Multiset.Entry<E>> iterator(){
            return entryIterator();
          }
          @Override public int size(){
            return distinctElements();
          }
        }
;
      }
      return result;
    }
    Iterator<Entry<E>> entryIterator(){
      final Iterator<Entry<E>> iterator1=multiset1.entrySet().iterator();
      return new AbstractIterator<Entry<E>>(){
        @Override protected Entry<E> computeNext(){
          while (iterator1.hasNext()) {
            Entry<E> entry1=iterator1.next();
            E element=entry1.getElement();
            int count=Math.min(entry1.getCount(),multiset2.count(element));
            if (count > 0) {
              return Multisets.immutableEntry(element,count);
            }
          }
          return endOfData();
        }
      }
;
    }
    int distinctElements(){
      return elementSet().size();
    }
  }
;
}
