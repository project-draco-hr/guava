{
  final CountDownLatch terminationLatch=new CountDownLatch(1);
  AbstractScheduledService service=new AbstractScheduledService(){
    volatile ScheduledExecutorService executorService;
    @Override protected void runOneIteration() throws Exception {
    }
    @Override protected ScheduledExecutorService executor(){
      if (executorService == null) {
        executorService=super.executor();
        addListener(new Listener(){
          @Override public void terminated(          State from){
            terminationLatch.countDown();
          }
        }
,MoreExecutors.sameThreadExecutor());
      }
      return executorService;
    }
    @Override protected Scheduler scheduler(){
      return Scheduler.newFixedDelaySchedule(0,1,TimeUnit.MILLISECONDS);
    }
  }
;
  service.startAsync();
  assertFalse(service.executor().isShutdown());
  service.awaitRunning();
  service.stopAsync();
  terminationLatch.await();
  assertTrue(service.executor().isShutdown());
  assertTrue(service.executor().awaitTermination(100,TimeUnit.MILLISECONDS));
}
