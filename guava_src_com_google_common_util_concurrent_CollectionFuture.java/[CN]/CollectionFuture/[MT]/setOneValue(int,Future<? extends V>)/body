{
  List<Optional<V>> localValues=values;
  if (isDone() || localValues == null) {
    checkState(allMustSucceed || isCancelled(),"Future was done before all dependencies completed");
  }
  try {
    checkState(future.isDone(),"Tried to set value from future which is not done");
    if (future.isCancelled()) {
      if (allMustSucceed) {
        super.cancel(false);
      }
    }
 else {
      V returnValue=getUninterruptibly(future);
      if (localValues != null) {
        localValues.set(index,Optional.fromNullable(returnValue));
      }
    }
  }
 catch (  ExecutionException e) {
    setExceptionAndMaybeLog(e.getCause());
  }
catch (  Throwable t) {
    setExceptionAndMaybeLog(t);
  }
 finally {
    int newRemaining=remaining.decrementAndGet();
    checkState(newRemaining >= 0,"Less than 0 remaining futures");
    if (newRemaining == 0) {
      FutureCollector<V,C> localCombiner=combiner;
      if (localCombiner != null && localValues != null) {
        set(localCombiner.combine(localValues));
      }
 else {
        checkState(isDone());
      }
      seenExceptions=null;
    }
  }
}
